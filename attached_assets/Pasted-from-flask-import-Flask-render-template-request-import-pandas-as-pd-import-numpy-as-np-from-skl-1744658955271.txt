from flask import Flask, render_template, request
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
import joblib
import optuna
import os

app = Flask(__name__)

# Simulated data for demonstration (replace with actual data processing in a real scenario)
def load_or_create_data():
    if not os.path.exists('data/processed_data.csv'):
        data = {
            'sample_size': [300, 350, 400, 450, 500],
            'duration': [40, 48, 52, 60, 36],
            'trial_outcome': ['success', 'failure', 'success', 'success', 'failure']
        }
        df = pd.DataFrame(data)
        df.to_csv('data/processed_data.csv', index=False)
    return pd.read_csv('data/processed_data.csv')

# Train or load a simple model
def train_or_load_model():
    if not os.path.exists('models/success_model.pkl'):
        df = load_or_create_data()
        X = df[['sample_size', 'duration']]
        y = df['trial_outcome'].apply(lambda x: 1 if x == 'success' else 0)
        model = RandomForestClassifier(n_estimators=100, random_state=42)
        model.fit(X, y)
        if not os.path.exists('models'):
            os.makedirs('models')
        joblib.dump(model, 'models/success_model.pkl')
    return joblib.load('models/success_model.pkl')

model = train_or_load_model()

# Recommendation engine using Optuna
def recommend_parameters():
    def objective(trial):
        sample_size = trial.suggest_int('sample_size', 200, 500)
        duration = trial.suggest_int('duration', 30, 60)
        prediction = model.predict_proba([[sample_size, duration]])[0][1]
        return prediction

    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=20)  # Reduced trials for faster execution
    return study.best_params

# Monte Carlo simulation for impact quantification
def monte_carlo_simulation(params, n_simulations=100):
    success_probs = []
    for _ in range(n_simulations):
        sample_size = np.random.normal(params['sample_size'], 10)
        duration = np.random.normal(params['duration'], 2)
        prob = model.predict_proba([[sample_size, duration]])[0][1]
        success_probs.append(prob)
    return np.mean(success_probs), np.std(success_probs)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analyze', methods=['POST'])
def analyze():
    sample_size = int(request.form['sample_size'])
    duration = int(request.form['duration'])
    prediction = model.predict_proba([[sample_size, duration]])[0][1]
    
    # Get recommendations
    best_params = recommend_parameters()
    mean_prob, std_prob = monte_carlo_simulation(best_params)
    
    return render_template('result.html', 
                         prediction=prediction,
                         best_sample_size=best_params['sample_size'],
                         best_duration=best_params['duration'],
                         mean_prob=mean_prob,
                         std_prob=std_prob)

if __name__ == '__main__':
    if not os.path.exists('data'):
        os.makedirs('data')
    app.run(host='0.0.0.0', port=8080, debug=True)