import express from 'express';
import fs from 'fs';
import path from 'path';
import PDFDocument from 'pdfkit';

const router = express.Router();

export const exportRoutes = router;

// Function to convert HTML content to plain text
function stripHtml(html: string): string {
  return html.replace(/<[^>]*>?/gm, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/\n\s*\n/g, '\n\n')  // Remove extra blank lines
    .trim();
}

// Function to format current date as yyyy-mm-dd
function getFormattedDate(): string {
  const today = new Date();
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

// Export to PDF format
router.post('/pdf', async (req, res) => {
  try {
    const { 
      title, 
      author = 'LumenTrialGuide.AI', 
      content,
      indication, 
      phase,
      csrInsights = [],
      academicReferences = []
    } = req.body;

    if (!content) {
      return res.status(400).json({ success: false, message: 'Content is required' });
    }

    // Create a new PDF document
    const doc = new PDFDocument({
      margins: { top: 50, bottom: 50, left: 50, right: 50 },
      size: 'A4',
      info: {
        Title: title || `Protocol Analysis for ${indication || ''} ${phase ? `(${phase})` : ''}`,
        Author: author,
        Subject: `Protocol Analysis for ${indication || 'Clinical Trial'} Study`,
        Keywords: `clinical trial, protocol, recommendations, ${indication || ''}, ${phase || ''}`,
        CreationDate: new Date()
      }
    });
    
    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(title || 'protocol-recommendations').replace(/%20/g, '_')}.pdf"`);
    
    // Pipe the PDF document to the response
    doc.pipe(res);
    
    // Define colors for consistent branding
    const primary = '#1e40af'; // deep blue
    const secondary = '#3b82f6'; // medium blue
    const accent = '#93c5fd'; // light blue
    const textColor = '#1e293b'; // slate
    const lightGray = '#e2e8f0'; // light gray for borders
    const lightBlue = '#dbeafe'; // very light blue for backgrounds
    
    // Add a cover page with a blue header
    doc.rect(0, 0, doc.page.width, 150)
       .fill(primary);
    
    // Add title
    doc.fillColor('white')
       .fontSize(24)
       .font('Helvetica-Bold')
       .text(title || `Protocol Recommendations for ${indication} Study (${phase ? phase.replace('phase', 'Phase ') : ''})`, 50, 70, {
         align: 'center',
         width: doc.page.width - 100
       });
    
    // Add subtitle if indication and phase are available
    if (indication || phase) {
      doc.moveDown(0.5)
         .fontSize(16)
         .font('Helvetica')
         .text(`${indication || ''} ${phase ? `(${phase.replace('phase', 'Phase ')})` : ''}`, {
           align: 'center',
           width: doc.page.width - 100
         });
    }
    
    // Add generation details
    doc.fillColor(textColor)
       .moveDown(4)
       .fontSize(12)
       .text(`Generated by ${author} on ${getFormattedDate()}`, {
         align: 'center',
         width: doc.page.width - 100
       });
    
    // Add description
    doc.moveDown(2)
       .fontSize(14)
       .fillColor(secondary)
       .font('Helvetica-Italic')
       .text('This document provides comprehensive protocol recommendations based on analysis of similar clinical trials, relevant academic research, and industry best practices.', {
         align: 'center',
         width: doc.page.width - 150
       });
    
    // Add metadata at the bottom
    doc.moveDown(6)
       .fillColor(textColor)
       .fontSize(10)
       .font('Helvetica')
       .text(`Document ID: LT-${Date.now().toString(36).toUpperCase()}`, {
         align: 'center'
       })
       .moveDown(0.5)
       .text(`Contains ${csrInsights.length} clinical study references and ${academicReferences.length} academic citations`, {
         align: 'center'
       });
    
    // Add a table of contents page
    doc.addPage();
    doc.fillColor(primary)
       .fontSize(18)
       .font('Helvetica-Bold')
       .text('Table of Contents', {
         align: 'left'
       });
    
    doc.moveDown(1);
    
    // Define sections for ToC
    const tocItems = [
      { title: 'Executive Summary', page: 3 }
    ];
    
    // Add sections based on content structure
    if (typeof content === 'object') {
      if (content.keySuggestions && content.keySuggestions.length > 0) {
        tocItems.push({ title: 'Key Suggestions', page: 4 });
      }
      if (content.suggestedEndpoints && content.suggestedEndpoints.length > 0) {
        tocItems.push({ title: 'Suggested Endpoints', page: 5 });
      }
      if (content.riskFactors && content.riskFactors.length > 0) {
        tocItems.push({ title: 'Risk Factors', page: 6 });
      }
    }
    
    // Add standard sections
    if (csrInsights && csrInsights.length > 0) {
      tocItems.push({ title: 'Relevant Clinical Study Reports', page: tocItems.length + 3 });
    }
    if (academicReferences && academicReferences.length > 0) {
      tocItems.push({ title: 'Academic References', page: tocItems.length + 3 });
    }
    
    // Draw ToC items
    tocItems.forEach((item, index) => {
      doc.fillColor(textColor)
         .fontSize(12)
         .font('Helvetica')
         .text(`${index + 1}. ${item.title}`, {
           continued: true,
           width: 400
         })
         .text('.'.repeat(30), {
           continued: true,
           align: 'right'
         })
         .text(` ${item.page}`, {
           align: 'right'
         });
      
      doc.moveDown(0.5);
    });
    
    // Add executive summary page
    doc.addPage();
    doc.fillColor(primary)
       .fontSize(16)
       .font('Helvetica-Bold')
       .text('Executive Summary');
    
    doc.moveDown(0.5)
       .fillColor(textColor)
       .fontSize(12)
       .font('Helvetica');
    
    // Process content based on type
    if (typeof content === 'string') {
      doc.text(stripHtml(content));
    } else if (typeof content === 'object') {
      if (content.recommendation) {
        doc.text(stripHtml(content.recommendation));
      }
      
      // Key Suggestions section
      if (content.keySuggestions && content.keySuggestions.length > 0) {
        doc.addPage();
        doc.fillColor(primary)
           .fontSize(16)
           .font('Helvetica-Bold')
           .text('Key Suggestions');
        
        doc.moveDown(0.5);
        
        // Add a light blue background
        const boxY = doc.y;
        const boxHeight = content.keySuggestions.length * 20 + 20;
        
        doc.rect(40, boxY - 10, doc.page.width - 80, boxHeight)
           .fillColor(lightBlue)
           .fillOpacity(0.3)
           .fill();
        
        doc.fillOpacity(1)
           .fillColor(textColor);
        
        // Add each suggestion as a bullet point
        content.keySuggestions.forEach((suggestion: string) => {
          doc.fontSize(12)
             .text(`• ${suggestion}`, {
               indent: 20,
               continued: false
             });
          doc.moveDown(0.3);
        });
      }
      
      // Suggested Endpoints section
      if (content.suggestedEndpoints && content.suggestedEndpoints.length > 0) {
        if (doc.y > 700 || content.keySuggestions) {
          doc.addPage();
        } else {
          doc.moveDown(2);
        }
        
        doc.fillColor(primary)
           .fontSize(16)
           .font('Helvetica-Bold')
           .text('Suggested Endpoints');
        
        doc.moveDown(0.5)
           .fillColor(textColor)
           .fontSize(12);
        
        content.suggestedEndpoints.forEach((endpoint: string) => {
          doc.text(`• ${endpoint}`, {
            indent: 20
          });
          doc.moveDown(0.3);
        });
      }
      
      // Risk Factors section
      if (content.riskFactors && content.riskFactors.length > 0) {
        if (doc.y > 650) {
          doc.addPage();
        } else {
          doc.moveDown(2);
        }
        
        doc.fillColor(primary)
           .fontSize(16)
           .font('Helvetica-Bold')
           .text('Risk Factors');
        
        doc.moveDown(0.5);
        
        // Add risk factors in red
        content.riskFactors.forEach((risk: string) => {
          doc.fillColor('#b91c1c') // red for risks
             .text(`• ${risk}`, {
               indent: 20
             });
          doc.moveDown(0.3);
        });
        
        doc.fillColor(textColor); // Reset color
      }
    }
    
    // CSR Insights section
    if (csrInsights && csrInsights.length > 0) {
      doc.addPage();
      
      doc.fillColor(primary)
         .fontSize(16)
         .font('Helvetica-Bold')
         .text('Relevant Clinical Study Reports');
      
      doc.moveDown(0.5)
         .fillColor(textColor);
      
      // Add intro text
      doc.fontSize(11)
         .font('Helvetica-Italic')
         .text('The following clinical studies provide relevant insights and precedents for this protocol.');
      
      doc.moveDown(1);
      
      // Add each CSR with background
      csrInsights.forEach((csr: any, index: number) => {
        const boxY = doc.y;
        const boxHeight = 120;
        
        // Alternate background colors
        const bgColor = index % 2 === 0 ? lightBlue : lightGray;
        
        doc.rect(40, boxY - 10, doc.page.width - 80, boxHeight)
           .fillColor(bgColor)
           .fillOpacity(0.3)
           .fill();
        
        doc.fillOpacity(1)
           .fillColor(primary)
           .fontSize(14)
           .font('Helvetica-Bold')
           .text(`${index + 1}. ${csr.title || 'Untitled Study'}`, 50, boxY);
        
        doc.moveDown(0.5)
           .fillColor(textColor)
           .fontSize(12)
           .font('Helvetica');
        
        // Display CSR metadata
        if (csr.indication) {
          doc.text(`Indication: ${csr.indication}`, {
            indent: 10,
            continued: false
          });
          doc.moveDown(0.3);
        }
        
        if (csr.phase) {
          doc.text(`Phase: ${csr.phase}`, {
            indent: 10,
            continued: false
          });
          doc.moveDown(0.3);
        }
        
        if (csr.sample_size) {
          doc.text(`Sample Size: ${csr.sample_size}`, {
            indent: 10,
            continued: false
          });
          doc.moveDown(0.3);
        }
        
        if (csr.sponsor) {
          doc.text(`Sponsor: ${csr.sponsor}`, {
            indent: 10,
            continued: false
          });
          doc.moveDown(0.3);
        }
        
        // Display key learnings
        if (csr.key_learnings && 
          (Array.isArray(csr.key_learnings) ? csr.key_learnings.length > 0 : csr.key_learnings)) {
          
          doc.moveDown(0.3)
             .font('Helvetica-Bold')
             .text('Key Learnings:', {
               indent: 10
             })
             .font('Helvetica');
          
          doc.moveDown(0.3);
          
          const learnings = Array.isArray(csr.key_learnings) 
            ? csr.key_learnings 
            : [csr.key_learnings];
          
          learnings.forEach((learning: string) => {
            doc.text(`• ${learning}`, {
              indent: 20,
              continued: false
            });
            doc.moveDown(0.3);
          });
        }
        
        doc.moveDown(1);
      });
    }
    
    // Academic References section
    if (academicReferences && academicReferences.length > 0) {
      doc.addPage();
      
      doc.fillColor(primary)
         .fontSize(16)
         .font('Helvetica-Bold')
         .text('Academic References');
      
      doc.moveDown(0.5);
      
      // Add description
      doc.fillColor(textColor)
         .fontSize(11)
         .font('Helvetica-Italic')
         .text('The following academic references provide scientific foundation and evidence for the recommendations in this document.');
      
      doc.moveDown(1)
         .fontSize(12)
         .font('Helvetica');
      
      // Format references in academic style
      academicReferences.forEach((ref: any, index: number) => {
        const authors = ref.author || 'Unknown Author';
        const year = ref.year || 'n.d.';
        const title = ref.title || 'Untitled';
        const publication = ref.publication || '';
        const volume = ref.volume ? `${ref.volume}` : '';
        const number = ref.number ? `(${ref.number})` : '';
        const pages = ref.pages ? `, pp. ${ref.pages}` : '';
        
        // Format reference number
        doc.font('Helvetica-Bold')
           .text(`${index + 1}.`, {
             continued: true,
             indent: 0
           });
        
        // Format author and year
        doc.font('Helvetica')
           .text(` ${authors} (${year}). `, {
             continued: true
           });
        
        // Format title in italics
        doc.font('Helvetica-Italic')
           .text(`${title}. `, {
             continued: true
           });
        
        // Format publication details
        doc.font('Helvetica')
           .text(`${publication}${volume ? ' ' + volume : ''}${number}${pages}.`);
        
        // Add DOI if available
        if (ref.doi) {
          doc.moveDown(0.3)
             .font('Helvetica-Bold')
             .text('DOI: ', {
               indent: 20,
               continued: true
             })
             .font('Helvetica')
             .text(ref.doi);
        }
        
        // Add relevance if available
        if (ref.relevance) {
          doc.moveDown(0.3)
             .font('Helvetica-Bold')
             .text('Relevance: ', {
               indent: 20,
               continued: true
             })
             .font('Helvetica-Italic')
             .text(ref.relevance);
        }
        
        doc.moveDown(1);
      });
    }
    
    // Add page numbering to all pages except cover
    const range = doc.bufferedPageRange();
    for (let i = 1; i < range.count; i++) {
      doc.switchToPage(i);
      
      // Add footer line
      doc.moveTo(50, doc.page.height - 50)
         .lineTo(doc.page.width - 50, doc.page.height - 50)
         .stroke();
      
      // Add page number
      doc.fontSize(10)
         .fillColor(textColor)
         .text(
           `Page ${i} of ${range.count - 1}`,
           50,
           doc.page.height - 40,
           { align: 'center', width: doc.page.width - 100 }
         );
    }
    
    // Finalize the PDF
    doc.end();
  } catch (error: any) {
    console.error('Error generating PDF:', error);
    res.status(500).json({
      success: false,
      message: `Failed to generate PDF: ${error.message}`
    });
  }
});

// Export to Word document format
router.post('/word', async (req, res) => {
  try {
    const { 
      title, 
      author = 'LumenTrialGuide.AI', 
      content,
      indication, 
      phase,
      csrInsights = [],
      academicReferences = []
    } = req.body;

    if (!content) {
      return res.status(400).json({ success: false, message: 'Content is required' });
    }

    // Create HTML document that Word can open
    let html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>${title || `Protocol Recommendations for ${indication} Study (${phase})`}</title>
  <style>
    body { font-family: Calibri, Arial, sans-serif; margin: 1in; }
    h1 { font-size: 18pt; margin-bottom: 0.5em; }
    h2 { font-size: 14pt; margin-top: 1.5em; margin-bottom: 0.5em; }
    p { font-size: 12pt; margin-bottom: 0.5em; }
    .author { font-style: italic; }
    .date { margin-bottom: 2em; }
    .reference { margin-left: 0.5in; text-indent: -0.5in; margin-bottom: 0.5em; }
    .container { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; }
    .risk { color: #b91c1c; }
    .heading { color: #1e40af; }
    .subheading { color: #3b82f6; }
  </style>
</head>
<body>
  <h1 class="heading">${title || `Protocol Recommendations for ${indication} Study (${phase})`}</h1>
  <p class="author">Author: ${author}</p>
  <p class="date">Date: ${getFormattedDate()}</p>
  
  <h2 class="heading">EXECUTIVE SUMMARY</h2>
  <div>${typeof content === 'string' ? content : JSON.stringify(content, null, 2)}</div>`;

    // Add Key Suggestions if available
    if (typeof content === 'object' && content.keySuggestions && content.keySuggestions.length > 0) {
      html += `
  <h2 class="heading">KEY SUGGESTIONS</h2>
  <div class="container">
    <ul>`;
      
      for (const suggestion of content.keySuggestions) {
        html += `
      <li>${suggestion}</li>`;
      }
      
      html += `
    </ul>
  </div>`;
    }

    // Add Suggested Endpoints if available
    if (typeof content === 'object' && content.suggestedEndpoints && content.suggestedEndpoints.length > 0) {
      html += `
  <h2 class="heading">SUGGESTED ENDPOINTS</h2>
  <ul>`;
      
      for (const endpoint of content.suggestedEndpoints) {
        html += `
    <li>${endpoint}</li>`;
      }
      
      html += `
  </ul>`;
    }

    // Add Risk Factors if available
    if (typeof content === 'object' && content.riskFactors && content.riskFactors.length > 0) {
      html += `
  <h2 class="heading">RISK FACTORS</h2>
  <ul>`;
      
      for (const risk of content.riskFactors) {
        html += `
    <li class="risk">${risk}</li>`;
      }
      
      html += `
  </ul>`;
    }

    // Add CSR insights if available
    if (csrInsights && csrInsights.length > 0) {
      html += `
  <h2 class="heading">RELEVANT CLINICAL STUDY REPORTS</h2>`;
      
      for (const csr of csrInsights.slice(0, 5)) { // Limit to first 5 CSRs
        html += `
  <div class="container">
    <p><strong>${csr.title || 'Untitled Study'}</strong></p>`;
        
        if (csr.indication) {
          html += `
    <p>Indication: ${csr.indication}</p>`;
        }
        
        if (csr.phase) {
          html += `
    <p>Phase: ${csr.phase}</p>`;
        }
        
        if (csr.sample_size) {
          html += `
    <p>Sample Size: ${csr.sample_size}</p>`;
        }
        
        if (csr.sponsor) {
          html += `
    <p>Sponsor: ${csr.sponsor}</p>`;
        }
        
        if (csr.key_learnings) {
          html += `
    <p><strong>Key Learnings:</strong></p>
    <ul>`;
          
          for (const learning of (Array.isArray(csr.key_learnings) ? csr.key_learnings : [csr.key_learnings])) {
            html += `
      <li>${learning}</li>`;
          }
          
          html += `
    </ul>`;
        }
        
        html += `
  </div>`;
      }
    }
    
    // Add academic references if available
    if (academicReferences && academicReferences.length > 0) {
      html += `
  <h2 class="heading">ACADEMIC REFERENCES</h2>
  <ol>`;
      
      for (const ref of academicReferences) {
        // Format in APA style
        const authors = ref.author || 'Unknown Author';
        const year = ref.year || 'n.d.';
        const title = ref.title || 'Untitled';
        const publication = ref.publication || 'Unknown Publication';
        const volume = ref.volume ? `, ${ref.volume}` : '';
        const number = ref.number ? `(${ref.number})` : '';
        const pages = ref.pages ? `, pp. ${ref.pages}` : '';
        
        html += `
    <li class="reference">${authors} (${year}). <em>${title}</em>. ${publication}${volume}${number}${pages}.`;
        
        if (ref.doi) {
          html += ` DOI: ${ref.doi}`;
        }
        
        if (ref.relevance) {
          html += `<br><strong>Relevance:</strong> <em>${ref.relevance}</em>`;
        }
        
        html += `</li>`;
      }
      
      html += `
  </ol>`;
    }
    
    // Close the HTML document
    html += `
</body>
</html>`;
    
    // Set response headers
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(title || 'protocol-recommendations').replace(/%20/g, '_')}.html"`);
    
    // Send the HTML content
    res.send(html);
  } catch (error: any) {
    console.error('Error generating Word document:', error);
    res.status(500).json({ 
      success: false, 
      message: `Failed to generate Word document: ${error.message}` 
    });
  }
});

// Export to CSV format
router.post('/csv', async (req, res) => {
  try {
    const { 
      content,
      csrInsights = [],
      academicReferences = []
    } = req.body;

    if (!content) {
      return res.status(400).json({ success: false, message: 'Content is required' });
    }

    // CSV header
    let csv = 'Type,Category,Content,Source\n';
    
    // Add main content
    if (typeof content === 'string') {
      // Simple string content
      csv += `Main,Summary,"${stripHtml(content).replace(/"/g, '""')}",LumenTrialGuide.AI\n`;
    } else if (typeof content === 'object') {
      // Add recommendations
      if (content.recommendation) {
        csv += `Main,Summary,"${stripHtml(content.recommendation).replace(/"/g, '""')}",LumenTrialGuide.AI\n`;
      }
      
      // Add key suggestions
      if (content.keySuggestions && Array.isArray(content.keySuggestions)) {
        for (const suggestion of content.keySuggestions) {
          csv += `Main,Key Suggestion,"${suggestion.replace(/"/g, '""')}",LumenTrialGuide.AI\n`;
        }
      }
      
      // Add endpoints
      if (content.suggestedEndpoints && Array.isArray(content.suggestedEndpoints)) {
        for (const endpoint of content.suggestedEndpoints) {
          csv += `Main,Endpoint,"${endpoint.replace(/"/g, '""')}",LumenTrialGuide.AI\n`;
        }
      }
      
      // Add risks
      if (content.riskFactors && Array.isArray(content.riskFactors)) {
        for (const risk of content.riskFactors) {
          csv += `Main,Risk Factor,"${risk.replace(/"/g, '""')}",LumenTrialGuide.AI\n`;
        }
      }
    }
    
    // Add CSR insights
    if (csrInsights && Array.isArray(csrInsights)) {
      for (const csr of csrInsights) {
        // Add basic CSR info
        csv += `CSR,Study,"${(csr.title || 'Untitled Study').replace(/"/g, '""')}",(ID: ${csr.id || 'Unknown'})\n`;
        
        // Add key learnings
        if (csr.key_learnings) {
          const learnings = Array.isArray(csr.key_learnings) ? csr.key_learnings : [csr.key_learnings];
          for (const learning of learnings) {
            csv += `CSR,Key Learning,"${learning.replace(/"/g, '""')}","${(csr.title || 'Untitled Study').replace(/"/g, '""')}"\n`;
          }
        }
      }
    }
    
    // Add academic references
    if (academicReferences && Array.isArray(academicReferences)) {
      for (const ref of academicReferences) {
        // Format reference
        const authors = ref.author || 'Unknown Author';
        const year = ref.year || 'n.d.';
        const title = ref.title || 'Untitled';
        const publication = ref.publication || 'Unknown Publication';
        
        csv += `Reference,Academic,"${title.replace(/"/g, '""')}","${authors.replace(/"/g, '""')} (${year})"\n`;
        
        // Add relevance if available
        if (ref.relevance) {
          csv += `Reference,Relevance,"${ref.relevance.replace(/"/g, '""')}","${authors.replace(/"/g, '""')} (${year})"\n`;
        }
      }
    }
    
    // Set response headers
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="protocol-recommendations-${getFormattedDate()}.csv"`);
    
    // Send the CSV content
    res.send(csv);
  } catch (error: any) {
    console.error('Error generating CSV:', error);
    res.status(500).json({ 
      success: false, 
      message: `Failed to generate CSV: ${error.message}` 
    });
  }
});

// Export to BibTeX format for citation management
router.post('/bibtex', async (req, res) => {
  try {
    const { academicReferences = [] } = req.body;

    if (!academicReferences || !Array.isArray(academicReferences) || academicReferences.length === 0) {
      return res.status(400).json({ success: false, message: 'Academic references are required for BibTeX export' });
    }

    // Generate BibTeX content
    let bibtex = '';
    
    for (const [index, ref] of academicReferences.entries()) {
      // Generate a unique citation key based on author, year and index
      const author = ref.author || 'Unknown';
      const year = ref.year || 'nd';
      const firstAuthor = author.split(',')[0].split(' ')[0].replace(/[^a-zA-Z]/g, '');
      const citationKey = `${firstAuthor.toLowerCase()}${year}${index}`;
      
      bibtex += `@article{${citationKey},\n`;
      bibtex += `  author = {${ref.author || 'Unknown Author'}},\n`;
      bibtex += `  title = {${ref.title || 'Untitled'}},\n`;
      bibtex += `  journal = {${ref.publication || 'Unknown Journal'}},\n`;
      bibtex += `  year = {${ref.year || 'n.d.'}},\n`;
      
      if (ref.volume) {
        bibtex += `  volume = {${ref.volume}},\n`;
      }
      
      if (ref.number) {
        bibtex += `  number = {${ref.number}},\n`;
      }
      
      if (ref.pages) {
        bibtex += `  pages = {${ref.pages}},\n`;
      }
      
      if (ref.doi) {
        bibtex += `  doi = {${ref.doi}},\n`;
      }
      
      bibtex += `  note = {Relevance: ${ref.relevance || 'Not specified'}}\n`;
      bibtex += `}\n\n`;
    }
    
    // Set response headers
    res.setHeader('Content-Type', 'application/x-bibtex');
    res.setHeader('Content-Disposition', `attachment; filename="protocol-references-${getFormattedDate()}.bib"`);
    
    // Send the BibTeX content
    res.send(bibtex);
  } catch (error: any) {
    console.error('Error generating BibTeX:', error);
    res.status(500).json({ 
      success: false, 
      message: `Failed to generate BibTeX: ${error.message}` 
    });
  }
});

// Export to RIS format for reference management programs like EndNote or Zotero
router.post('/ris', async (req, res) => {
  try {
    const { academicReferences = [] } = req.body;

    if (!academicReferences || !Array.isArray(academicReferences) || academicReferences.length === 0) {
      return res.status(400).json({ success: false, message: 'Academic references are required for RIS export' });
    }

    // Generate RIS content
    let ris = '';
    
    for (const ref of academicReferences) {
      ris += 'TY  - JOUR\n';  // Type: Journal Article
      
      // Add authors - split by commas or 'and'
      const authors = (ref.author || 'Unknown Author').split(/,|\sand\s/);
      for (const author of authors) {
        if (author.trim()) {
          ris += `AU  - ${author.trim()}\n`;
        }
      }
      
      ris += `TI  - ${ref.title || 'Untitled'}\n`;
      ris += `JO  - ${ref.publication || 'Unknown Journal'}\n`;
      ris += `PY  - ${ref.year || 'n.d.'}\n`;  // Publication Year
      
      if (ref.volume) {
        ris += `VL  - ${ref.volume}\n`;  // Volume
      }
      
      if (ref.number) {
        ris += `IS  - ${ref.number}\n`;  // Issue
      }
      
      if (ref.pages) {
        ris += `SP  - ${ref.pages.split('-')[0]}\n`;  // Start Page
        
        const pageRange = ref.pages.split('-');
        if (pageRange.length > 1) {
          ris += `EP  - ${pageRange[1]}\n`;  // End Page
        }
      }
      
      if (ref.doi) {
        ris += `DO  - ${ref.doi}\n`;  // DOI
      }
      
      if (ref.relevance) {
        ris += `N1  - Relevance: ${ref.relevance}\n`;  // Notes
      }
      
      ris += 'ER  - \n\n';  // End of Reference
    }
    
    // Set response headers
    res.setHeader('Content-Type', 'application/x-research-info-systems');
    res.setHeader('Content-Disposition', `attachment; filename="protocol-references-${getFormattedDate()}.ris"`);
    
    // Send the RIS content
    res.send(ris);
  } catch (error: any) {
    console.error('Error generating RIS:', error);
    res.status(500).json({ 
      success: false, 
      message: `Failed to generate RIS: ${error.message}` 
    });
  }
});

// Export to Markdown format for easy integration with documentation
router.post('/markdown', async (req, res) => {
  try {
    const { 
      title, 
      author = 'LumenTrialGuide.AI', 
      content,
      indication, 
      phase,
      csrInsights = [],
      academicReferences = []
    } = req.body;

    if (!content) {
      return res.status(400).json({ success: false, message: 'Content is required' });
    }

    // Generate Markdown content
    let markdown = `# ${title || `Protocol Recommendations for ${indication} Study (${phase})`}\n\n`;
    markdown += `*Author: ${author}*  \n`;
    markdown += `*Date: ${getFormattedDate()}*\n\n`;
    
    // Add main content
    markdown += `## Executive Summary\n\n`;
    
    if (typeof content === 'string') {
      markdown += `${stripHtml(content)}\n\n`;
    } else if (typeof content === 'object') {
      if (content.recommendation) {
        markdown += `${stripHtml(content.recommendation)}\n\n`;
      }
      
      // Key Suggestions
      if (content.keySuggestions && content.keySuggestions.length > 0) {
        markdown += `## Key Suggestions\n\n`;
        
        for (const suggestion of content.keySuggestions) {
          markdown += `- ${suggestion}\n`;
        }
        
        markdown += '\n';
      }
      
      // Suggested Endpoints
      if (content.suggestedEndpoints && content.suggestedEndpoints.length > 0) {
        markdown += `## Suggested Endpoints\n\n`;
        
        for (const endpoint of content.suggestedEndpoints) {
          markdown += `- ${endpoint}\n`;
        }
        
        markdown += '\n';
      }
      
      // Risk Factors
      if (content.riskFactors && content.riskFactors.length > 0) {
        markdown += `## Risk Factors\n\n`;
        
        for (const risk of content.riskFactors) {
          markdown += `- **⚠️ ${risk}**\n`;
        }
        
        markdown += '\n';
      }
    }
    
    // CSR Insights
    if (csrInsights && csrInsights.length > 0) {
      markdown += `## Relevant Clinical Study Reports\n\n`;
      
      for (const csr of csrInsights) {
        markdown += `### ${csr.title || 'Untitled Study'}\n\n`;
        
        // Add metadata fields
        const metadataFields = [];
        if (csr.indication) metadataFields.push(`**Indication:** ${csr.indication}`);
        if (csr.phase) metadataFields.push(`**Phase:** ${csr.phase}`);
        if (csr.sample_size) metadataFields.push(`**Sample Size:** ${csr.sample_size}`);
        if (csr.sponsor) metadataFields.push(`**Sponsor:** ${csr.sponsor}`);
        
        if (metadataFields.length > 0) {
          markdown += `${metadataFields.join(' | ')}\n\n`;
        }
        
        // Add key learnings
        if (csr.key_learnings) {
          markdown += `**Key Learnings:**\n\n`;
          
          const learnings = Array.isArray(csr.key_learnings) ? csr.key_learnings : [csr.key_learnings];
          
          for (const learning of learnings) {
            markdown += `- ${learning}\n`;
          }
          
          markdown += '\n';
        }
      }
    }
    
    // Academic References
    if (academicReferences && academicReferences.length > 0) {
      markdown += `## Academic References\n\n`;
      
      for (const [index, ref] of academicReferences.entries()) {
        const authors = ref.author || 'Unknown Author';
        const year = ref.year || 'n.d.';
        const title = ref.title || 'Untitled';
        const publication = ref.publication || 'Unknown Publication';
        const volume = ref.volume ? `, ${ref.volume}` : '';
        const number = ref.number ? `(${ref.number})` : '';
        const pages = ref.pages ? `, pp. ${ref.pages}` : '';
        
        markdown += `${index + 1}. ${authors} (${year}). *${title}*. ${publication}${volume}${number}${pages}`;
        
        if (ref.doi) {
          markdown += `. DOI: [${ref.doi}](https://doi.org/${ref.doi})`;
        }
        
        markdown += '\n';
        
        if (ref.relevance) {
          markdown += `   - *Relevance:* ${ref.relevance}\n`;
        }
        
        markdown += '\n';
      }
    }
    
    // Set response headers
    res.setHeader('Content-Type', 'text/markdown');
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(title || 'protocol-recommendations').replace(/%20/g, '_')}.md"`);
    
    // Send the Markdown content
    res.send(markdown);
  } catch (error: any) {
    console.error('Error generating Markdown:', error);
    res.status(500).json({ 
      success: false, 
      message: `Failed to generate Markdown: ${error.message}` 
    });
  }
});

// Export to XML format for data exchange
router.post('/xml', async (req, res) => {
  try {
    const { 
      title, 
      author = 'LumenTrialGuide.AI', 
      content,
      indication, 
      phase,
      csrInsights = [],
      academicReferences = []
    } = req.body;

    if (!content) {
      return res.status(400).json({ success: false, message: 'Content is required' });
    }

    // Generate XML header and root element
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<ProtocolRecommendations xmlns="https://lumen.ai/protocol/recommendations/1.0">\n';
    
    // Add metadata section
    xml += '  <Metadata>\n';
    xml += `    <Title>${title || `Protocol Recommendations for ${indication} Study (${phase})`}</Title>\n`;
    xml += `    <Author>${author}</Author>\n`;
    xml += `    <GenerationDate>${getFormattedDate()}</GenerationDate>\n`;
    if (indication) xml += `    <Indication>${indication}</Indication>\n`;
    if (phase) xml += `    <Phase>${phase}</Phase>\n`;
    xml += '  </Metadata>\n';
    
    // Add recommendations section
    xml += '  <Recommendations>\n';
    
    if (typeof content === 'string') {
      xml += '    <Summary>\n';
      xml += `      <Text>${stripHtml(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Text>\n`;
      xml += '    </Summary>\n';
    } else if (typeof content === 'object') {
      if (content.recommendation) {
        xml += '    <Summary>\n';
        xml += `      <Text>${stripHtml(content.recommendation).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Text>\n`;
        xml += '    </Summary>\n';
      }
      
      // Key Suggestions
      if (content.keySuggestions && content.keySuggestions.length > 0) {
        xml += '    <KeySuggestions>\n';
        
        for (const suggestion of content.keySuggestions) {
          xml += `      <Suggestion>${suggestion.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Suggestion>\n`;
        }
        
        xml += '    </KeySuggestions>\n';
      }
      
      // Suggested Endpoints
      if (content.suggestedEndpoints && content.suggestedEndpoints.length > 0) {
        xml += '    <Endpoints>\n';
        
        for (const endpoint of content.suggestedEndpoints) {
          xml += `      <Endpoint>${endpoint.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Endpoint>\n`;
        }
        
        xml += '    </Endpoints>\n';
      }
      
      // Risk Factors
      if (content.riskFactors && content.riskFactors.length > 0) {
        xml += '    <RiskFactors>\n';
        
        for (const risk of content.riskFactors) {
          xml += `      <Risk>${risk.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Risk>\n`;
        }
        
        xml += '    </RiskFactors>\n';
      }
      
      // Section Analysis if available
      if (content.sectionAnalysis) {
        xml += '    <SectionAnalysis>\n';
        
        for (const [section, analysis] of Object.entries(content.sectionAnalysis)) {
          if (!analysis) continue;
          
          xml += `      <Section id="${section.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}">\n`;
          
          if (analysis.current) {
            xml += `        <CurrentStatus>${analysis.current.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</CurrentStatus>\n`;
          }
          
          if (analysis.alignment) {
            xml += `        <AlignmentScore>${analysis.alignment}</AlignmentScore>\n`;
          }
          
          if (analysis.suggestions && analysis.suggestions.length > 0) {
            xml += '        <Suggestions>\n';
            
            for (const suggestion of analysis.suggestions) {
              xml += `          <Suggestion>${suggestion.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Suggestion>\n`;
            }
            
            xml += '        </Suggestions>\n';
          }
          
          if (analysis.academicGuidance) {
            xml += `        <AcademicGuidance>${analysis.academicGuidance.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</AcademicGuidance>\n`;
          }
          
          xml += '      </Section>\n';
        }
        
        xml += '    </SectionAnalysis>\n';
      }
    }
    
    xml += '  </Recommendations>\n';
    
    // Add CSR Insights
    if (csrInsights && csrInsights.length > 0) {
      xml += '  <ClinicalStudyReports>\n';
      
      for (const csr of csrInsights) {
        xml += '    <ClinicalStudyReport>\n';
        xml += `      <Title>${(csr.title || 'Untitled Study').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Title>\n`;
        
        if (csr.id) xml += `      <ID>${csr.id}</ID>\n`;
        if (csr.indication) xml += `      <Indication>${csr.indication.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Indication>\n`;
        if (csr.phase) xml += `      <Phase>${csr.phase.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Phase>\n`;
        if (csr.sample_size) xml += `      <SampleSize>${csr.sample_size}</SampleSize>\n`;
        if (csr.sponsor) xml += `      <Sponsor>${csr.sponsor.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Sponsor>\n`;
        
        // Add key learnings
        if (csr.key_learnings) {
          xml += '      <KeyLearnings>\n';
          
          const learnings = Array.isArray(csr.key_learnings) ? csr.key_learnings : [csr.key_learnings];
          
          for (const learning of learnings) {
            xml += `        <Learning>${learning.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Learning>\n`;
          }
          
          xml += '      </KeyLearnings>\n';
        }
        
        xml += '    </ClinicalStudyReport>\n';
      }
      
      xml += '  </ClinicalStudyReports>\n';
    }
    
    // Add Academic References
    if (academicReferences && academicReferences.length > 0) {
      xml += '  <AcademicReferences>\n';
      
      for (const ref of academicReferences) {
        xml += '    <Reference>\n';
        
        if (ref.author) xml += `      <Author>${ref.author.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Author>\n`;
        if (ref.year) xml += `      <Year>${ref.year}</Year>\n`;
        if (ref.title) xml += `      <Title>${ref.title.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Title>\n`;
        if (ref.publication) xml += `      <Publication>${ref.publication.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Publication>\n`;
        if (ref.volume) xml += `      <Volume>${ref.volume}</Volume>\n`;
        if (ref.number) xml += `      <Number>${ref.number}</Number>\n`;
        if (ref.pages) xml += `      <Pages>${ref.pages}</Pages>\n`;
        if (ref.doi) xml += `      <DOI>${ref.doi}</DOI>\n`;
        if (ref.relevance) xml += `      <Relevance>${ref.relevance.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</Relevance>\n`;
        
        xml += '    </Reference>\n';
      }
      
      xml += '  </AcademicReferences>\n';
    }
    
    // Close the root element
    xml += '</ProtocolRecommendations>';
    
    // Set response headers
    res.setHeader('Content-Type', 'application/xml');
    res.setHeader('Content-Disposition', `attachment; filename="${encodeURIComponent(title || 'protocol-recommendations').replace(/%20/g, '_')}.xml"`);
    
    // Send the XML content
    res.send(xml);
  } catch (error: any) {
    console.error('Error generating XML:', error);
    res.status(500).json({ 
      success: false, 
      message: `Failed to generate XML: ${error.message}` 
    });
  }
});